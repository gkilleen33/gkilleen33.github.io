# geGMM 

This Python package implements flexible GMM estimation with spatial HAC standard errors (Conley 1999, 2008). It also has tools for assisting with analysis for research on the project "General Equilibrium Effects of Cash Transfers." This builds on the Statsmodels GMM implementation, and most features and documentation of that package remain valid.

## Installation 

1.) Download this folder. 

2.) Navigate to the folder in a terminal with your Python environment and type python `setup.py sdist.` 

3.) Now enter `pip install dist/geGMM-0.0.1.tar.gz` where the number may need to be updated to different versions. If you don't want to update dependencies, instead enter `pip install --no-deps dist/geGMM-0.0.1.tar.gz`

4.) You can now import the package using `import geGMM` in any Python script in this environment. 

## Instructions 

### Arbitrary moment conditions 

The package supports estimating an arbitrary vector of moment conditions using GMM. The following code provides an example of this functionality: 

```python
import pandas as pd
import numpy as np 
import geGMM

df = pd.read_stata('EL2_data_path/ENT_EL2_PAP_OUTCOMES.dta', convert_categoricals=False)
df.dropna(subset=['treat'], inplace=True)  # Matches EL2 enterprise PAP analysis 


moments = [
    'z[0]*(y - params[0]*x[0] - params[1]*x[1])',
    'z[1]*(y - params[0]*x[0] - params[1]*x[1])',
    'z[2]*(y - params[0]*x[0] - params[1]*x[1])',
    'z[3]*(y - params[0]*x[0] - params[1]*x[1])'
    ]

gmm_model_interacted = geGMM.geGMM(moments=moments, 
                  data = df, 
                  dep_vars = ['ent_pap_3_1_2'],
                  exog = 'C(ent_type):pp_actamt_0to2km', 
                  instruments = 'C(ent_type):share_ge_elig_treat_0to2km + C(ent_type):share_ge_elig_treat_0to2km:share_ge_elig_0to2km',
                  pweights = 'ent_weight_el2',
                  controls = 'C(ent_type) + C(ent_type):share_ge_elig_0to2km + C(wave)')

beta0 = np.ones(2)
gmm_results_interacted = gmm_model_interacted.fit(beta0, maxiter = 2, optim_method='nm')  # Just identified so just want one-step
print(gmm_results_interacted.summary())

```

Exogenous variables, instruments, and controls are specified via Patsy strings, so for instance `exog = 'C(ent_type):pp_actamt_0to2km'` will generate interactions of `pp_actamt_0to2km` with levels of `ent_type`. If a list of strings is passed to the class via the argument `parameters`, then the parameter names will be assigned from the list. Otherwise, the class assumes the parameter names should equal the names of the exogenous variables. Controls are partialled out before the moment conditions are calculated, so need not be specified in moment conditions. 

Moments are specified as strings. When using a single endogenous variable, it will be accessed using `y` in the string as in this example. With multiple endogenous variables, access them with `y[0]`, `y[1]`, etc. Instruments, `z[0]`, etc and exogenous variables, `x[0]`, etc are accessed similarly. Parameters are accessed via `params[0]`, `params[1]`, etc. The exogenous variables and instruments will be ordered based on the creation of the dataframe generated by Patsy. So in this instance, `x[0]` is `1.ent_type#pp_actamt_0to2km` and `x[1]` is `2.ent_type#pp_actamt_0to2km`. Once the class is initialized, one could call `gmm_model_interacted.exogenous_names` to get the `x` columns and `gmm_model_interacted.instrument_names` to get the instrument names. 

A full list of the arguments that may be passed to the class and attributes returned is here: 

```
Custom GMM class that incorporates Conley SEs and is customized for ease of use on the GE project.
Parameters
----------
data: Pandas dataframe 
dep_vars: List of dependent variables.  
exog: A Patsy formula specifying which exogenous variables (x) to include 
instruments: A Pasty formula specifying which instruments (z) to include 
moments: (Optional) List of moment conditions. Each moment condition should be a string where parameters are 
    accessed using the list p, instruments using the list z, and exogenous variables using x. If not set 
    assumes each exogenous variable, instrument should be used linearly for every endogenous variable.
latitude: Variables name containing latitude 
longitude: Variable name containing longitude 
pweights: (Optional) variable name containing inverse probability weights  
controls: (Optional) Patsy formula with controls to partial out 
other_vars: (Optional) list of other variables to append to data, without partialling out controls (e.g. sample indicators)
distance_cutoff: Default 10km: spatial distance cutoff for Conley error estimation in km
kernel (str default 'uniform'): If 'uniform' uses a uniform kernel. If 'bartlett' uses a Bartlett kernel. 
parameters: A list of parameter names, as strings. Optional if simple IV case. Required if using other moments.

Attributes
----------
n_exog : int
    Number of exogenous variables
n_endog : int
    Number of endogenous variables
n_inst : int 
    Number of instruments 
weights : ndarray
    Inverse probability weights, if specified 
moments : list
    List of moment conditions
instrument_names: list 
    List of instrument names
exog_names: list 
    List of exogenous variable names
parameters: list 
    List of parameter names, if included
other_vars: ndarray
    Other variables passed to class

Methods
-------
_partialOutControls(data, var_list, controls, weight_name=None)
    Partials out controls from each variable in var_list. Used internally.
```

After the model has been fit, one may estimate a linear combination using 

```
t_test = gmm_results_interacted.t_test('100*C(ent_type)[1.0]:pp_actamt_0to2km + 200*C(ent_type)[2.0]:pp_actamt_0to2km')
print(t_test) 
print(t_test.effect[0])
print(t_test.sd[0][0])
print(t_test.pvalue)
```

One may similarly estimate Wald tests of multiple hypotheses. See the Statsmodels documentation for these effects. 

### Instrumental variable regression 

If one simply wishes to estimate IV regression using GMM, they may omit the moment conditions in which case the vector of moment conditions `x*( y - x'beta)` will be calculated, and `beta` will be returned. The previous model could be fit identically by instead passing

```python
gmm_model_interacted = geGMM.geGMM( 
                  data = df, 
                  dep_vars = ['ent_pap_3_1_2'],
                  exog = 'C(ent_type):pp_actamt_0to2km', 
                  instruments = 'C(ent_type):share_ge_elig_treat_0to2km + C(ent_type):share_ge_elig_treat_0to2km:share_ge_elig_0to2km',
                  pweights = 'ent_weight_el2',
                  controls = 'C(ent_type) + C(ent_type):share_ge_elig_0to2km + C(wave)')
```

### Optimal radii calculation 

The function `geGMM.calculate_optimal_radii()` returns the radius of `pp_actamt_{r2}to{r}km`, etc, that minimizes BIC. The following example shows how one could call this function, then use the optimal radius to fit a model. 

```python
optr, opt_exog, opt_inst, opt_control = geGMM.calculate_optimal_radii(df, 'r_ent_pap_3_3_4_PPP_wins', ['C(ent_type):pp_actamt_{}to{}km'], 
                                                                ['C(ent_type):share_ge_elig_treat_{}to{}km',
                                                                 'C(ent_type):share_ge_elig_treat_{}to{}km:share_ge_elig_{}to{}km'], 
                                                                dynamic_controls = ['C(ent_type):share_ge_elig_{}to{}km'],
                                                                static_controls='C(ent_type) + C(wave)', pweights='ent_weight_el2')

model_ent_test = geGMM.geGMM(df, ['r_ent_pap_3_1_2_wins'], exog=opt_exog, instruments=opt_inst, controls=opt_control, pweights='ent_weight_el2')
ent_results = model_ent_test.fit(beta0, maxiter = 2, optim_method='nm')
```

Here is documentation for the function 

```python
def calculate_optimal_radii(data, endog, dynamic_exog, dynamic_instruments, static_instruments=None, 
                            static_exog=None, static_controls=None, dynamic_controls=None, monotonic=True,
                            latitude='latitude', longitude='longitude', kernel='uniform', distance_cutoff=10, pweights=None, maxiter=1,
                            optim_method='bfgs', optim_args=None, addBLcontrols='enterprise'):
    """
    Figures out the optimal radius for a scalar outcome and a set of instruments by minimizing BIC. Only supports a single outcome.

    Args: 
        data (Pandas DataFrame): Data for estimation 
        endog (str): Name of endogenous variable 
        dynamic_exog (list of Patsy formulas): Dynamic exogenous variables in form of var_{}to{}km, where {} and {} will be filled with r-2 r km in loop. 
            These will be instrumented for (see dynamic_controls for optional controls)
        dynamic_instruments: (list of Patsy formulas) Dynamic instruments in form of var_{}to{}km, where {} and {} will be filled with r-2 r km in loop
        static_instruments: (optional str): Patsy string with any static instruments to include 
        static_controls: (optional str): Patsy string with any static controls (e.g. FEs) to include 
        dynamic_controls: (optional list of Patsy formulas): Spatially varying controls specified as Patsys formulas of var_{}to{}km, where {} and {} will be filled with r-2 r km in loop
        monotonic: (Default True). If True, stops once BIC increases and returns the prior value. Faster but less robust. 
        latitude (str): Name of latitude variable in data 
        longitude (str): Name of longitude variable in data
        kernel (str default 'uniform'): If 'uniform' uses a uniform kernel. If 'bartlett' uses a Bartlett kernel. If 'pos_def' uses (1 - dist/dist_cutoff)^2 to ensure positive definite covariance. 
        distance_cutoff (float default 10): Distance cutoff for kernel in km 
        pweights (optional, str): Name of column containing inverse probability weights in data 
        maxiter: (int default 1): Maximum number of GMM iterations. Default is 1, but if using 2 step GMM performance is better with set to 2.
        optim_method: (str, default 'bfgs') : scipy optimization method. bfgs is default for speed, 'nm' is more robust but slower. 
        optim_args: (optional, dict) : dictionary of arguments for the optimization algorithm (e.g. increase max iterations)
        addBLcontrols: (str, default 'enterprise') : searches for and adds BL controls if available. Default is to add enterprise BL controls.
            Currently only enterprise supported.

    Returns:
        opt_r, selected_exogenous, selected_instruments, selected_controls 

        opt_r is an integer with the selected maximum radius 
        optimal_exogenous is a Patsy string of the selected exogenous variables 
        optimal_instruments is a Patsy string with the selected set of instruments 
        optimal_controls is a Patsy string with the selected set of controls 
    """
```

### Average total effects 

I have added average total effect calculation for enterprise results. This is essentially just a t-test, but it automates some of the redundant weight calculation which speeds up coding for convenience when estimating many specifications. After the last example, one could call 

```python
ate = average_total_effect(ent_results, el2_ent_data=df)

print(ate['b_total'])
print(ate['se_total'])
print(ate['p_total'])

print(ate['b_spillover'])
print(ate['se_spillover'])
print(ate['p_spillover'])

```

Contact me to add other ATE calculations (e.g. household). 
